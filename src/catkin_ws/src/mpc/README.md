# MPC

This repository implements (robust) MPC-based planning and tracking for nonlinear mobile robots using solvers generated by ForcesPro. The solver generation and runtime code are implemented in an efficient and modular way. Therefore, it is relatively straightforward to customize it to your own setting by changing the model, objective function, constraints and runtime system- or interface-specific code. Refer to [How to customize?](#how-to-customize) for more information.

Contents:\
[Install](#install)\
[Generate solver](#generate-solver)\
[Build](#build)\
[Run](#run)\
[How to customize?](#how-to-customize)

## Install

1. The solver generation code is implemented using Python 3. Therefore, make sure to have Python 3 installed. The code is tested using Python 3.8.10.

2. Install ForcesPro Python solver client using the instructions provided in the [documentation](https://forces.embotech.com/Documentation). The code is tested using ForcesPro client 6.3.0. A few notes:
   - Make sure to have a floating license, since the code runs in a Dockerized environment.
   - Unzip the downloaded client into the user home directory (_~/_ or _/home/USERNAME_), since this directory is checked to find the client in the solver generation code.

## Generate solver

To generate a solver, use the file [setup_script.sh](./mpc_solver/setup_script.sh) in the [mpc_solver](./mpc_solver) package. This script requires the following arguments:

- `-c` or `--config` to specify the configuration file(s) that contain the solver settings. The available options are [pmpc_settings.py](./mpc_solver/scripts/systems/falcon/pmpc_settings.py) and [tmpc_settings.py](./mpc_solver/scripts/systems/falcon/tmpc_settings.py).
- `-s` or `--system` to specify the system for which the solver should be generated. The available option is `falcon`.
- `-f` or `--floating_license_platform` to specify the platform for which the solver should be generated. The available options are `ARM` and `x86`.
- `-n` or `--no-build` to only build the solver interface, not the solver itself.

To generate the solver for robust output-feedback hierarchical MPC (ROHMPC), execute the following command:

```bash
./setup_script.sh -c tmpc_settings.py -c pmpc_settings.py -s falcon -f ARM
```

> :bulb: Add the following lines to your _~/.bashrc_ file to easily navigate to the solver generation directory and generate the solver:
>
> ```bash
> alias cdmpcsolver='cd <path_to_repo>/src/catkin_ws/src/mpc/mpc_solver'
> alias mpc_generate_solver_rompc='cdmpcsolver; ./setup_script.sh -c tmpc_settings.py -c pmpc_settings.py -s falcon -f ARM'
> ```

> :bulb: You can play around with the sampling times and predictions horizons of the PMPC and TMPC to improve performance. See [pmpc_settings.py](./mpc_solver/scripts/systems/falcon/pmpc_settings.py) and [tmpc_settings.py](./mpc_solver/scripts/systems/falcon/tmpc_settings.py) for more details.

## Build

After generating the solver and solver interface, you can build the runtime C++ code. Generally, this is automatically built when using a catkin workspace and running `catkin build <package_name>`.

## Run

The Falcon version of this repository is used in combination with the [Agilicious](https://github.com/uzh-rpg/agilicious) stack. Therefore, there is no launch file included in this repository.

## How to customize?

Interested in using this MPC package for your setup? This is relatively straightforward by following these steps:

- Define the solver generation settings in the [mpc_solver](./mpc_solver) package:
  - Add a new directory with your system name to the [systems](./mpc_solver/scripts/systems) directory.
  - Add a settings file to the new system directory. This file should contain the solver settings, such as the model, objective function, constraints, and solver settings.
  - Implement the system model in [dynamics.py](./mpc_solver/scripts/include/dynamics.py), the system constraints in [systems.py](./mpc_solver/scripts/include/systems.py), the objective function in [objective.py](./mpc_solver/scripts/include/objective.py), and the inequality constraints in [inequality.py](./mpc_solver/scripts/include/inequality.py).
  - When defining a new type of objective or inequality constraint, make sure to add it as a new control module to [control_modules.py](./mpc_solver/scripts/include/control_modules.py). These control modules are used to bridge between offline Python solver generation and online C++ code since they usually require a specific number of parameters to be set in the runtime code.
  - Implement the offline computations in [offline_computations.py](./mpc_solver/scripts/include/offline_computations/offline_computations.py). For the offline computations you might want to leverage the [mpc-sdp](./mpc_solver/scripts/include/offline_computations/mpc-sdp) package.
  - See [falcon](./mpc_solver/scripts/systems/falcon) system for an example.
- Define the system-specific runtime code in the [mpc_systems](./mpc_systems) package:
  - Add a new directory with your system name to the [mpc_systems](./mpc_systems) package.
  - Implement the system-specific code in the new system directory. This code should contain the ROS interface, the system-specific runtime code, and the system-specific launch files.
  - See the [mpc_falcon](./mpc_systems/mpc_falcon) package for an example.
- Define the runtime code corresponding to the new control modules to the [mpc_modules](./mpc_modules) package in a similar way as the currently implemented control modules are defined. Do not forget to include the new control modules in the corresponding [CMakeLists.txt](./mpc_modules/CMakeLists.txt) file.
